package ma.betteryou.betteryoubackend.service.ai;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import ma.betteryou.betteryoubackend.ai.OpenAiClient;
import ma.betteryou.betteryoubackend.dto.ai.GenerateProgramRequest;
import ma.betteryou.betteryoubackend.dto.exercise.ExercisePickDto;
import ma.betteryou.betteryoubackend.dto.exercise.ExerciseRequest;
import ma.betteryou.betteryoubackend.dto.exercise.SessionRequest;
import ma.betteryou.betteryoubackend.dto.program.ProgramWizardResponse;
import ma.betteryou.betteryoubackend.entity.user.User;
import ma.betteryou.betteryoubackend.repository.Workout.ExerciseRepository;
import ma.betteryou.betteryoubackend.repository.Workout.UserRepositoryR;
import ma.betteryou.betteryoubackend.service.ProgramWizardProgramService;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AiProgramService {

    private final OpenAiClient openAiClient;
    private final ObjectMapper objectMapper;
    private final UserRepositoryR userRepository;
    private final ExerciseRepository exerciseRepository;
    private final ProgramWizardProgramService programWizardProgramService;

    private static final String SYSTEM = """
Tu es un coach sportif.
Tu dois retourner un JSON STRICT (sans texte).
Contraintes:
- Programme sur EXACTEMENT 7 jours (dayIndex 1..7).
- Respecter l'objectif utilisateur (goal) fourni.
- Chaque jour DOIT avoir des exercices (pas de jour REST).
- sessionType uniquement: STRENGTH, CARDIO, ou MIXED
- Retourne UNIQUEMENT le JSON.
Format JSON:
{
 "programName":"...",
 "description":"...",
 "days":[
  {
   "dayIndex":1,
   "dayLabel":"Day 1",
   "sessionType":"STRENGTH|CARDIO|MIXED",
   "durationMinutes":45,
   "exercises":[
     {"idExercise":123,"sets":3,"reps":10,"restSeconds":60,"orderInSession":1}
   ]
  }
 ]
}
""";
    public ProgramWizardResponse generateWeekProgram(GenerateProgramRequest req) {

        Long userId = req.getUserId();
        if (userId == null) throw new IllegalArgumentException("userId is required");

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));

        String goal = String.valueOf(user.getGoal());
        LocalDate startDate = LocalDate.now();

        // ✅ Récupérer les IDs exercices existants
        List<Long> allowedIds = exerciseRepository.findAllIds();
        if (allowedIds == null || allowedIds.isEmpty()) {
            throw new IllegalStateException("No exercises found in DB. Seed exercise table first.");
        }
        Set<Long> allowedSet = new HashSet<>(allowedIds);

        // limiter pour le prompt (sinon trop long)
        String allowedIdsText = allowedIds.stream()
                .limit(60)
                .map(String::valueOf)
                .collect(Collectors.joining(", "));

        String userNotes = req.getUserNotes() == null ? "" : req.getUserNotes().trim();

String prompt = """
User goal (from DB): %s
Optional user notes: %s

IMPORTANT:
- You MUST choose idExercise only from this allowed list:
[%s]
- Do NOT invent ids outside this list.
- Generate exactly 7 days (dayIndex 1..7).
- EVERY day MUST have exercises (no REST days allowed).
- sessionType must be one of: STRENGTH, CARDIO, MIXED
""".formatted(goal, userNotes, allowedIdsText);

        // --- appel IA ---
        String json = openAiClient.chatJson(SYSTEM, prompt);

        // --- parse ---
        AiWeekProgram ai = parseAi(json);

        if (ai.days == null || ai.days.size() != 7) {
            throw new IllegalStateException("AI must generate exactly 7 days. Got: " + (ai.days == null ? 0 : ai.days.size()));
        }

        // --- payload wizard ---
        ExercisePickDto payload = new ExercisePickDto();
        payload.setProgramName(nonEmptyOr(ai.programName, "AI Program (1 week)"));
        payload.setDescription(nonEmptyOr(ai.description, "Generated by AI based on your goal: " + goal));
        payload.setGoal(goal);

        // ✅ IMPORTANT: mets une valeur ACCEPTÉE par ta DB
        // si ta contrainte accepte seulement MANUAL, garde MANUAL
        payload.setGenerationType("AUTO_AI"); // ou "AUTO" si ta DB l’accepte

        ai.days.sort(Comparator.comparingInt(d -> d.dayIndex));
        List<SessionRequest> sessions = new ArrayList<>();

        for (AiDay d : ai.days) {
    if (d.dayIndex < 1 || d.dayIndex > 7) {
        throw new IllegalStateException("Invalid dayIndex: " + d.dayIndex);
    }

    LocalDate sessionDate = startDate.plusDays(d.dayIndex - 1);

    SessionRequest sr = new SessionRequest();

    // ✅ Valider le sessionType — fallback sur STRENGTH si invalide
    String type = d.sessionType != null ? d.sessionType.toUpperCase() : "STRENGTH";
    if (!List.of("STRENGTH", "CARDIO", "MIXED").contains(type)) {
        type = "STRENGTH";
    }
    sr.setSessionType(type);

    // ✅ Durée toujours > 0
    int duration = d.durationMinutes == null ? 45 : Math.max(20, Math.min(75, d.durationMinutes));
    sr.setDurationMinutes(duration);
    sr.setSessionDate(sessionDate);

    // ✅ Exercices pour tous les types
    List<ExerciseRequest> exs = new ArrayList<>();
    if (d.exercises != null) {
        int orderFallback = 1;
        for (AiExercise e : d.exercises) {
            Long chosen = e.idExercise;
            if (chosen == null || !allowedSet.contains(chosen)) {
                chosen = allowedIds.get(0);
            }
            ExerciseRequest ex = new ExerciseRequest();
            ex.setIdExercise(chosen);
            ex.setSets(e.sets != null ? e.sets : 3);
            ex.setReps(e.reps != null ? e.reps : 10);
            ex.setRestSeconds(e.restSeconds != null ? e.restSeconds : 60);
            ex.setOrderInSession(e.orderInSession != null ? e.orderInSession : orderFallback++);
            exs.add(ex);
        }
    }

    // ✅ Fallback si IA renvoie une liste vide
    if (exs.isEmpty()) {
        ExerciseRequest ex = new ExerciseRequest();
        ex.setIdExercise(allowedIds.get(0));
        ex.setSets(3);
        ex.setReps(10);
        ex.setRestSeconds(60);
        ex.setOrderInSession(1);
        exs.add(ex);
    }

    sr.setExercises(exs);
    sessions.add(sr);
}

        payload.setSessions(sessions);

        return programWizardProgramService.createProgram(userId, payload);
    }

    private AiWeekProgram parseAi(String json) {
        try {
            return objectMapper.readValue(json, AiWeekProgram.class);
        } catch (Exception e) {
            throw new RuntimeException("Invalid AI JSON. Content was: " + json, e);
        }
    }

    private String nonEmptyOr(String v, String fallback) {
        if (v == null) return fallback;
        String t = v.trim();
        return t.isEmpty() ? fallback : t;
    }

    // ==== parser classes ====
    public static class AiWeekProgram {
        public String programName;
        public String description;
        public List<AiDay> days;
    }

    public static class AiDay {
        public int dayIndex;
        public String dayLabel;
        public String sessionType;
        public Integer durationMinutes;
        public List<AiExercise> exercises;
    }

    public static class AiExercise {
        public Long idExercise;
        public Integer sets;
        public Integer reps;
        public Integer restSeconds;
        public Integer orderInSession;
    }
}
